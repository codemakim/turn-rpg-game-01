---
alwaysApply: true
---
# TypeScript 게임 개발 가이드라인

## 프로젝트 목표

- TypeScript로 **턴제 RPG** 게임 개발 (이 워크스페이스)
- 모바일 및 데스크톱 크로스 플랫폼 지원
- 재사용 가능한 게임 엔진 아키텍처 구축 (향후 다른 게임에 활용)

## 개발 전략

- **한 번에 하나의 게임만 개발** (현재: 턴제 RPG)
- 다른 게임은 별도 워크스페이스에서 진행
- 공통 코드는 향후 별도 라이브러리로 추출 가능

## 코드 작성 원칙

### 1. 아키텍처 패턴

- **ECS (Entity-Component-System)** 패턴 권장: 게임 오브젝트를 데이터와 로직으로 분리
- **상태 관리**: FSM (Finite State Machine) 또는 상태 패턴 활용
- **이벤트 시스템**: 느슨한 결합을 위한 이벤트 버스 패턴 사용
- **싱글톤 최소화**: DI (의존성 주입) 패턴 우선 고려

### 2. TypeScript 활용

- 강력한 타입 정의 사용 (any 타입 지양)
- 제네릭 적극 활용
- interface와 type 적절히 사용
- **모든 public 메서드/함수에 JSDoc 주석 작성**
- **모든 interface/type에 설명 주석 추가**
- **복잡한 로직에는 인라인 주석으로 설명**

#### 주석 작성 예시

```typescript
/**
 * 캐릭터의 기본 스탯 정보
 */
export interface CharacterStats {
  /** 캐릭터 이름 */
  name: string;
  /** 현재 체력 */
  hp: number;
  /** 최대 체력 (선택, 기본값: hp) */
  maxHp?: number;
}

/**
 * 게임 캐릭터 클래스
 * 플레이어와 적 모두 이 클래스를 사용
 */
export class Character {
  /**
   * 데미지를 받아 HP를 감소시킴
   * @param amount 받을 데미지량
   */
  takeDamage(amount: number): void {
    // HP는 0 이하로 내려가지 않음
    this.hp = Math.max(0, this.hp - amount);
  }
  
  /**
   * HP를 회복함
   * @param amount 회복량
   */
  heal(amount: number): void {
    // maxHp를 초과할 수 없음
    this.hp = Math.min(this.maxHp, this.hp + amount);
  }
}
```

### 3. 게임 루프 및 성능

- **requestAnimationFrame** 사용: 부드러운 60 FPS 유지
- **Delta Time** 계산: 프레임 독립적인 움직임 구현
- **Object Pooling**: 빈번한 객체 생성/삭제 방지
- **Dirty Flag 패턴**: 불필요한 재계산 방지

### 4. 파일 구조 (턴제 RPG - Phaser 3 기반)

```text
src/
├── main.ts                    # 🎮 Phaser 게임 시작점
├── core/                      # 게임 엔진 코어
│   └── Scene.ts              # ✅ 씬 베이스 클래스
├── characters/                # 캐릭터 관련
│   └── Character.ts          # ✅ 캐릭터 클래스
├── battle/                    # 전투 시스템 (로직)
│   ├── BattleController.ts   # ✅ 전투 로직 컨트롤러
│   ├── EnemyAI.ts            # ✅ 적 AI 시스템
│   ├── TurnQueue.ts          # ✅ 턴 순서 관리
│   ├── DamageCalculator.ts   # ✅ 데미지 계산
│   └── Skill.ts              # ✅ 스킬 시스템
├── scenes/                    # Phaser 씬
│   └── PhaserBattleScene.ts  # ✅ 전투 씬 (Phaser 기반)
├── utils/                     # 유틸리티
│   └── SkillLoader.ts        # ✅ 스킬 데이터 로더
├── demo/                      # 데모/테스트
│   └── battleDemo.ts         # ✅ 콘솔 전투 데모
└── 테스트 파일들/
    ├── Character.test.ts
    ├── DamageCalculator.test.ts
    ├── TurnQueue.test.ts
    ├── Skill.test.ts
    ├── EnemyAI.test.ts
    └── BattleSimulation.test.ts

# 향후 추가 예정 (Phase 5+):
├── systems/
│   ├── SaveManager.ts        # ⬜ 세이브/로드
│   ├── InventoryManager.ts   # ⬜ 인벤토리
│   └── EquipmentManager.ts   # ⬜ 장비 시스템
├── scenes/
│   ├── TitleScene.ts         # ⬜ 타이틀 화면 (Phaser)
│   ├── ShopScene.ts          # ⬜ 상점 (Phaser)
│   ├── MapScene.ts           # ⬜ 맵/필드 (Phaser)
│   └── InventoryScene.ts     # ⬜ 인벤토리 화면 (Phaser)
└── data/
    ├── items.json            # ⬜ 아이템 데이터
    ├── equipment.json        # ⬜ 장비 데이터
    └── enemies.json          # ⬜ 적 데이터
```

### 5. 턴제 RPG 핵심 시스템

- **턴 큐**: 속도(AGI) 기반 행동 순서, 턴 게이지 시스템
- **커맨드 패턴**: 행동을 객체로 캡슐화, 실행 취소/재실행 가능
- **전투 계산기**: 데미지 공식, 크리티컬/회피 확률 계산
- **스킬 시스템**: MP 소모, 타겟팅(단일/전체/아군), 즉시/지속 효과
- **AI 시스템**: 규칙 기반 적 행동 패턴

### 6. 기타 시스템

- **렌더링**: Phaser 3 (씬 시스템, 애니메이션, 타일맵 지원)
- **입력**: Phaser 내장 입력 시스템 (마우스/터치/키보드)
- **데이터**: JSON 기반 타입 안전 로더
- **저장**: LocalStorage 또는 IndexedDB
- **사운드**: Phaser 오디오 시스템
- **애니메이션**: Phaser Tweens

## 사용 라이브러리

- **Phaser 3**: 게임 엔진 (렌더링, 씬 관리, 입력, 사운드)
- **필요시 추가**: zustand(상태관리), howler.js(고급 오디오)

## 일반 작업 원칙

### 개발 순서 (턴제 RPG)

1. **Phase 1: 핵심 전투 시스템** ✅
   - Character 클래스 (HP, MP, 스탯)
   - 기본 공격 시스템
   - 턴 큐 (속도 기반 순서 관리)
   - 콘솔 기반 테스트

2. **Phase 2: UI 렌더링** ✅
   - Canvas → Phaser 3로 전환
   - 캐릭터 HP/MP 표시
   - 버튼 UI (공격, 스킬)
   - 터치/클릭 입력 (Phaser 자동 처리)

3. **Phase 3: 스킬 시스템** ✅
   - 스킬 데이터 정의
   - MP 소모 및 효과
   - 타겟팅 시스템 (단일/자신)

4. **Phase 4: 적 AI** ✅
   - EnemyAI 클래스 (상황별 행동 결정)
   - 적도 스킬 사용
   - HP 기반 회복 판단

5. **Phase 5a: 폴리싱** (게임 완성도 향상)
   - 애니메이션 (Phaser Tweens)
     - 데미지 숫자 표시
     - 캐릭터 흔들림
     - 버튼 호버 효과
   - 사운드 (Phaser Audio)
     - 공격 효과음
     - 스킬 효과음
     - 배경 음악

6. **Phase 5b: 콘텐츠 확장** (게임 볼륨 증가)
   - 여러 종류의 적 (슬라임, 고블린, 오크)
   - 더 많은 스킬 (JSON 데이터)
   - 난이도별 적 밸런싱

7. **Phase 6: 메타 시스템** (RPG 요소 강화)
   - 전투 보상 (경험치, 골드, 아이템)
   - 레벨업 시스템
   - 장비 시스템 (무기, 방어구)
   - 인벤토리 시스템

8. **Phase 7: 게임 확장** (완전한 RPG)
   - TitleScene (타이틀 화면)
   - MapScene (노드 기반 또는 필드 이동)
   - ShopScene (아이템/장비 구매)
   - InventoryScene (아이템/장비 관리)
   - 세이브/로드 시스템

### 작업 방식

- 한 번에 하나의 Phase에 집중
- 각 Phase 완료 후 플레이 테스트
- 모바일 터치와 데스크톱 마우스 모두 지원
- 성능 최적화는 기능 구현 후 진행
- 코드는 재사용 가능하게 작성 (향후 다른 게임에 활용)

## 현재 시스템 아키텍처 이해

### 핵심 컴포넌트 관계

#### 1. 전투 시스템 흐름

- **PhaserBattleScene**: Phaser 씬, UI 렌더링, 사용자 입력 처리
- **BattleController**: 전투 로직, 턴 관리, 이벤트 발생
- **TurnQueue**: 턴 게이지 관리, 즉시 점프 시스템으로 대기 시간 제거
- **Character**: 플레이어/적 캐릭터 데이터와 기본 행동
- **EnemyAI**: 적 행동 결정 로직
- **Skill**: 스킬 시스템, MP 소모, 타겟팅
- **DamageCalculator**: 데미지 계산, 크리티컬, 방어력 고려

#### 2. 이벤트 시스템

- BattleController → PhaserBattleScene: 전투 이벤트 전달
- 이벤트 타입: turn-start, attack, skill, damage, heal, turn-end
- PhaserBattleScene에서 이벤트 수신하여 애니메이션과 UI 업데이트

#### 3. 턴 시스템 (즉시 점프)

- 매 프레임마다 TurnQueue.updateGauges() 호출
- 다음 업데이트까지 아무도 100 도달 못하면 즉시 점프
- 가장 빨리 100 도달할 캐릭터까지 시간 계산 후 모든 캐릭터 동시 업데이트
- consumeTurn()에서 행동한 캐릭터만 100 차감

#### 4. 현재 상태 (Phase 5a 완료)

- ✅ 핵심 전투 시스템 완성
- ✅ Phaser 3 기반 UI 및 애니메이션
- ✅ 스킬 시스템 및 적 AI
- ✅ 즉시 점프 턴 시스템
- ✅ 61개 테스트 케이스 통과

## 개발 워크플로우

### 필수 개발 프로세스 (절대 위반 금지)

#### 1. 계획 수립 (Plan) - 필수

- **모든 변경사항은 반드시 계획부터 시작**
- **AI는 todo_write 도구를 사용하여 계획을 작성**
- **사용자 승인 없이는 절대 구현하지 않음**
- 복잡한 수정은 단계별로 나누어 계획

#### 2. 영향 범위 분석 (Impact Analysis) - 필수

- **변경하려는 파일과 관련된 모든 파일 파악**
- **기존 동작에 미치는 영향 분석**
- **테스트 케이스 영향 범위 확인**
- **사용자에게 영향 범위 설명**

#### 3. 테스트 우선 (Test First) - 필수

- **구현 전에 먼저 테스트 작성**
- **기존 테스트가 실패하면 수정 후 진행**
- **새로운 기능은 반드시 테스트 추가**

#### 4. 단계별 구현 (Step-by-step Implementation)

- **한 번에 하나의 변경사항만 적용**
- **각 단계마다 테스트 실행**
- **테스트 실패 시 즉시 중단하고 원인 분석**

#### 5. 검증 (Validation) - 필수

- **구현 완료 후 반드시 `npm test -- --run` 실행**
- **모든 테스트 통과 확인**
- **브라우저에서 실제 동작 확인**

#### 6. 커밋 (Commit) - 최종 단계

- **테스트 통과 후에만 커밋**
- **명확한 커밋 메시지 작성**
- **사용자에게 커밋 내용 설명**

### 코드 품질 관리 원칙

#### 1. 변경 전 상태 파악

- **수정하려는 코드의 현재 동작 방식 완전 이해**
- **관련 파일들의 의존성 관계 파악**
- **테스트 케이스의 기대값 이해**

#### 2. 안전한 수정 방법

- **기존 기능을 망가뜨리지 않는 선에서 수정**
- **새로운 기능은 기존 코드와 분리하여 추가**
- **복잡한 수정은 여러 단계로 나누어 진행**

#### 3. 일관성 유지

- **기존 코드 스타일과 패턴 유지**
- **동일한 문제를 여러 번 반복하지 않음**
- **설계 원칙과 아키텍처 패턴 준수**

### 테스트 환경 설정

```bash
npm install -D vitest @vitest/ui
```

package.json에 스크립트 추가: `"test": "vitest"`

vitest.config.ts 설정: globals, jsdom, path alias (@)

### 작업 중단 시 인수인계

AI는 작업 중단 시 완료된 작업, 진행 중인 작업, 다음 할 일을 명확히 남깁니다.

## 실수 방지 체크리스트

### 변경사항 적용 전 필수 확인사항

- [ ] 현재 시스템 상태와 변경 목적을 명확히 파악했는가?
- [ ] 관련 파일들의 의존성과 영향 범위를 분석했는가?
- [ ] 기존 테스트 케이스의 기대값을 이해했는가?
- [ ] 사용자에게 계획을 설명하고 승인을 받았는가?

### 구현 중 필수 확인사항

- [ ] 한 번에 하나의 변경사항만 적용하고 있는가?
- [ ] 각 단계마다 테스트를 실행하고 있는가?
- [ ] 테스트 실패 시 즉시 중단하고 원인을 분석하고 있는가?
- [ ] 기존 기능을 망가뜨리지 않고 있는가?

### 완료 전 필수 확인사항

- [ ] 모든 테스트가 통과하는가?
- [ ] 브라우저에서 실제 동작이 정상인가?
- [ ] 변경사항이 의도한 대로 동작하는가?
- [ ] 사용자에게 결과를 설명하고 커밋 승인을 받았는가?

## 주의사항

- 브라우저 호환성 체크 (특히 모바일 Safari)
- 메모리 누수 방지 (이벤트 리스너 정리)
- 에러 핸들링 (리소스 로딩 실패 등)
- 접근성 고려 (키보드 내비게이션, 색약 모드)
- **절대 계획 없이 바로 코드 수정하지 않기**
- **절대 테스트 없이 커밋하지 않기**
- **절대 사용자 승인 없이 큰 변경사항 적용하지 않기**
